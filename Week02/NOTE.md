学习笔记

哈希表（Hash table）也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
这个映射函数叫做散列函数，存放记录的数组叫做哈希表（散列表）。
哈希碰撞：不同的值，经过哈希换数之后会得到一个相同的值。
解决哈希碰撞的办法：在发生碰撞的位置放入一个链表，也就是拉链式解决冲突法。将相同哈希值的位置存放对应元素的列表，哈希函数的查询时间复杂度是O(1)的，增加、删除、查询时间复杂度均为O(1),最坏情况下为O(n) 
java中对应的就是Map(key-value对，key不重复)和Set(不重复元素的集合)

树、二叉树、二叉搜索树
树：有根节点，有左右子节点；
二叉树：儿子节点只有两个；
树和图的区别在于有没有环，图有环，树没有
Linked List是特殊化的Tree;Tree是特殊化的Graph;
二叉树遍历：前序：根-左-右；中序：左-根-右；后序：左-右-根
二叉搜索树：也称二叉排序树、有序二叉树、排序二叉树，是指一棵空树或者具有下列性质的二叉树：
	1.左子树所有节点的值均小于它的根节点的值；
	2.右子树所有节点的值均大于它的根节点的值；
	3.以此类推：左右子树也分别为二叉查找树。
中序遍历：升序排列
查询操作的时间复杂度都是logN的；

堆：可以迅速找到一堆数中的最大或最小值得数据结构；
将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆；
常见的堆有二叉堆、斐波那契堆等；
如果是大顶堆的话，常见操作的时间复杂度为：
find-maxO(1)
delete-maxO(logN)
insert(create):O(logN)或O(1);
二叉堆通过完全二叉树来实现（不是二叉搜索树）；
二叉堆满足：
	1.是一棵完全树；
	2.树中任意节点的值总是>=其子节点的值；
二叉堆一般都通过“数组”来实现；
假设第一个元素在数组中的索引为0的话，父节点和子节点的位置关系：索引为i的左孩子索引为2*i+1;右孩子的索引是2*i+2;索引为i的父节点的索引为floor((i-1)/2)
insert插入操作：O(logN)
新元素一律先插入到堆的尾部；依次向上调整整个堆的结构（一直到根即可）；HeapifyUp
Delete Max（删除堆顶操作）
1.将堆尾元素替换到顶部（即堆顶被替换删除掉）
2.依次从根部向下调整整个堆的结构（一直到堆尾即可）HeapifyDown

做题总结

* 在做题的过程中对于想到的办法或者思路在代码实现上存在一定程度上的实现难度，原因是对不常用到的API不熟悉，需要有针对性地熟悉涉及类的常用方法，比如日常中用到的比较多的是ArrayList,在一些题解中用到的是LinkedList,一些差异性的API会成为做题过程中的比较耗时的环节。
* 想到的第一反应是暴力求解，其次才会是课程中的解法，这个还需要不断地加快刷题的实现思路，缩短在暴力求解方法上的耗时。
* 对于比较精妙的解法还是需要钻研和记录。

